\documentclass[dvips,12pt]{article}

\setlength{\oddsidemargin}{0.1in}
\setlength{\evensidemargin}{0.1in}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
% These force using more of the margins that is the default style

\usepackage{longtable}

\usepackage{listings}
\usepackage{color} % for colored solution
\usepackage[svgnames]{xcolor}

% Custom colors for XML
\definecolor{maroon}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\lstdefinelanguage{XML}
{
    basicstyle=\ttfamily\footnotesize,
    morestring=[b]",
    moredelim=[s][\bfseries\color{Maroon}]{<}{\ },
    moredelim=[s][\bfseries\color{Maroon}]{</}{>},
    moredelim=[l][\bfseries\color{Maroon}]{/>},
    moredelim=[l][\bfseries\color{Maroon}]{>},
    morecomment=[s]{<?}{?>},
    morecomment=[s]{<!--}{-->},
    commentstyle=\color{DarkOliveGreen},
    stringstyle=\color{blue},
    identifierstyle=\color{red}
    %morekeywords={name,type,scope,address,value,to,from,
    %              initial\_condition,reference}
}
\lstset
{
    language=XML,
    basicstyle=\footnotesize\ttfamily,
    tabsize=4,
    keepspaces=false,
    keywordstyle=\color{red},
    identifierstyle=\color{blue},
    commentstyle=\color{green},
    frame=single,
    captionpos=t%, % sets the caption-position to top
    %morestring=[s]{"}{"},
    %morecomment=[s]{!--}{--},
    %morekeywords={name,type,scope,address,value,to,from,
    %              initial\_condition,reference}
}

\newcommand{\includecode}[1]{\lstinputlisting[caption=#1]{#1}}

\begin{document}

\title{VisLang: A graphical programming language}
\author{Bryant Eisenbach}
\date{\today}
\maketitle
% This command causes the title to be created in the document

\section{Introduction}

VisLang is a block diagram language designed to allow fast and
easy prototyping of programs for embedded processors. The language is created
with a graphical editor in mind, and the core language is designed to be extensible
so that any graphical editor can add additional elements or attributes for graphical
display or other features.

\section{Key Language Features}

The language itself is based on the idea of blocks: small parts that can be grouped
together into ever larger blocks and re-used across a program or programs. A small
group of fundamental (or atomic) blocks will be defined that will be understood by the
compiler for this language. Other blocks will be constructed as configurations of
these atomic blocks. A standard library of useful functions will be constructed
from these atomic blocks containing common parts such as timers, latches, etc. However,
this standard library is not required, and the ability to include parts libraries and
other blocks is a standard feature of the language.

Side effects in the produced code will be minimized by the combination of a strong
type system and bounded code execution. The type system of VisLang supports common
datatypes such as boolean, single, double, signed and unsigned integers, as well as
static arrays and structures of these simple datatypes. Bounded code execution is
guarenteed through the restriction of array operations to use a static size. This
works well with embedded processors as programs should only need to parse through
large buffers such as those implemented for I/O using digital busses, whose buffers
are typically defined as being a static size. The language will contain
implementations of the popular methods map, filter, and reduce to enable operating
on arrays. VisLang will also have methods for defining digital message structures
and how to parse those structures into the signals used by the program. Methods
for parsing both packet-based (e.g. Ethernet) and word-based (e.g. RS232)
will be provided by the standard library.

Lastly, time variance will be something provided fundamentally by the language.
The time-step between subsequent iterations will be maintained in every VisLang program
and provided to the user as needed as a atomic part. Most of the atomic parts will be
time-invariant as they are pure functions, but this language feature will provide users
with the ability to create dynamic parts that will care about time as a measured quantity
to create parts such as digital filters, derivatives, integrators, etc.

\section{Syntax}

The syntax of VisLang leverages standard XML, giving the language a well-formed and machine
readable backbone. As noted previously, the point of leveraging XML is so that 3rd party
programs can manipulate the file format in an easy way, and so that those programs can add
additional elements (e.g. visual comment blocks) and attributes (e.g. location information)
to the existing set of elements and attributes defined by the language. Those tags (including
XML comment tags) not included in the list of recognized elements/attributes will be 
ignored by the compiler, however this decision should have minimal impact on ambigious
errors when compiling programs due to the restriction that all parts requiring the necessary
attributes, and that all connections requiring the source to exist. This creates a natural
flow to interpreting the language, such that any errors should be raised by the compiler
during compilation. 

Below is the list of standard elements, and their required attributes:
\begin{longtable}[c]{ |c|c|c|c| } 
    \hline
    element & input(s) & outputs & attributes [optional]  \\ 
    \hline\hline
    INPUT & none & provides 'name' & scope, name, type, [address] \\ 
    OUTPUT & provides 'name' & none & scope, name, type, [address] \\ 
    CONSTANT & none & provides 'name' & name, type, value \\ 
    SIGNAL & provides 'name' & none & scope, name, type \\ 
    \hline
    BLOCK & as defined & as defined & name, [reference] \\ 
    PROGRAM & device inputs & device, global outputs & name \\ 
    CONNECTION & none & none & to, from \\
    \hline
    MEM & current & stored & name, initial\_condition \\
    DT & none & dt & name \\
    NOT & input & output & name \\
    AND & input\# (\# $>$ 1) & output & name \\
    OR & input\# (\# $>$ 1) & output & name \\
    NOR & input\# (\# $>$ 1) & output & name \\
    NAND & input\# (\# $>$ 1) & output & name \\
    XOR & input\# (\# $>$ 1) & output & name \\
    IF & control, true, false & output & name \\
    COMPARE & lhs, rhs  & output & name \\
    SUM & input\# (\# $>$ 1) & output & name \\
    PROD & input\# (\# $>$ 1) & output & name \\
    GAIN & input & output & name, value \\
    INV & input & output & name \\
    \hline
    MUX & input\# (\# $>$ 1) & provides 'array' & scope, name, type, size, [address] \\
    DEMUX & array & output\# (\# $>$ 1) & scope, name, type, size, [address] \\
    STRUCT & none & provides 'struct' & name, member\# (\# $>$ 0) \\
    CONSTRUCT & by definition & provides 'name' & scope, name, definition \\
    DESTRUCT & struct & by definition & scope, name, definition \\
    \hline
    MAP & input (array) & output (array) & name, func (SISO block ref) \\
    FILTER & input (array) & output (array) & name, func (SISO block ref)\\
    REDUCE & input (array) & output & name, func (MISO block ref) \\
    \hline
\end{longtable}

The first group of elements (INPUT, OUTPUT, CONSTANT, NAME) provide named
memory locations for use in the application. All of these elements have a
type attribute where the INPUT, OUTPUT, and SIGNAL all have a 

\section{Example Program}

The following program illustrates some of the major features of the language. The
program itself takes a Digital Input on the target device, reads it, and starts a
timer when the input is enabled. When the timer counts up to the target time, it
will set a Digital Output true and reset the timer, creating a fast-blinking light
with a period of 2 seconds.

\includecode{../example/timed-blinking-light/timed-blinking-light.vs}

As noted, the above file contained a reference to another part called timer defined
in timer.vs in the same directory. Any references must take place on a relative path
to that file, and that reference must contain the same number of inputs specified by
the target file inside the file referencing that part. The number of outputs need
not match, but any outputs specified in the file referencing that part must also
match what is available from the target file or an exception will be thrown. All
other unused outputs will be disregarded. The following file displays the target
file, complete with the relevant inputs and outputs as specified/required by the
previous file.

\includecode{../example/timed-blinking-light/timer.vs}

\end{document}

