\documentclass[dvips,10pt]{article}

\setlength{\oddsidemargin}{0.1in}
\setlength{\evensidemargin}{0.1in}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
% These force using more of the margins that is the default style

\usepackage{longtable}

\usepackage{listings}
\usepackage{color} % for colored solution
\usepackage[svgnames]{xcolor}

% Custom colors for XML
\definecolor{maroon}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\lstdefinelanguage{XML}
{
    basicstyle=\ttfamily\footnotesize,
    morestring=[b]",
    moredelim=[s][\bfseries\color{Maroon}]{<}{\ },
    moredelim=[s][\bfseries\color{Maroon}]{</}{>},
    moredelim=[l][\bfseries\color{Maroon}]{/>},
    moredelim=[l][\bfseries\color{Maroon}]{>},
    morecomment=[s]{<?}{?>},
    morecomment=[s]{<!--}{-->},
    commentstyle=\color{DarkOliveGreen},
    stringstyle=\color{blue},
    identifierstyle=\color{red}
    %morekeywords={name,type,scope,address,value,to,from,
    %              initial\_condition,reference}
}
\lstset
{
    language=XML,
    basicstyle=\footnotesize\ttfamily,
    tabsize=4,
    keepspaces=false,
    keywordstyle=\color{red},
    identifierstyle=\color{blue},
    commentstyle=\color{green},
    frame=single,
    captionpos=t%, % sets the caption-position to top
    %morestring=[s]{"}{"},
    %morecomment=[s]{!--}{--},
    %morekeywords={name,type,scope,address,value,to,from,
    %              initial\_condition,reference}
}

\newcommand{\includecode}[1]{\lstinputlisting[caption=#1]{#1}}

\begin{document}

\title{VisLang: A graphical programming language}
\author{Bryant Eisenbach}
\date{\today}
\maketitle
% This command causes the title to be created in the document

\section{Introduction}

VisLang is a block diagram language designed to allow fast and
easy prototyping of programs for embedded processors. The language is created
with a graphical editor in mind, and the core language is designed to be extensible
so that any graphical editor can add additional elements or attributes for graphical
display or other features.

\section{Key Language Features}

The language itself is based on the idea of blocks: small parts that can be grouped
together into ever larger blocks and re-used across a program or programs. A small
group of fundamental (or atomic) blocks will be defined that will be understood by the
compiler for this language. Other blocks will be constructed as configurations of
these atomic blocks. A standard library of useful functions will be constructed
from these atomic blocks containing common parts such as timers, latches, etc. However,
this standard library is not required, and the ability to include parts libraries and
other blocks is a standard feature of the language.

Side effects in the produced code will be minimized by the combination of a strong
type system and bounded code execution. The type system of VisLang supports common
datatypes such as boolean, single, double, signed and unsigned integers, as well as
static arrays and structures of these simple datatypes. Bounded code execution is
guarenteed through the restriction of array operations to use a static size. This
works well with embedded processors as programs should only need to parse through
large buffers such as those implemented for I/O using digital busses, whose buffers
are typically defined as being a static size. The language will contain
implementations of the popular methods map, filter, and reduce to enable operating
on arrays. This will allow VisLang to have methods for working with digital message
structures and parsing those structures into the signals that can used by the program.
Some standard implementations for parsing both packet-based (e.g. Ethernet) and word-based
(e.g. RS232) buffer data will be provided by the standard library.

Lastly, time variance will be something provided fundamentally by the language.
The time-step between subsequent iterations will be maintained in every VisLang program
and provided to the user as needed as a atomic part. Most of the atomic parts will be
time-invariant as they are pure functions, but this language feature will provide users
with the ability to create dynamic parts that will care about time as a measured quantity
to create parts such as digital filters, derivatives, integrators, etc.

\section{Syntax}

The syntax of VisLang leverages standard XML, giving the language a well-formed and machine
readable backbone. As noted previously, the point of leveraging XML is so that 3rd party
programs can manipulate the file format in an easy way, and so that those programs can add
additional elements (e.g. visual comment blocks) and attributes (e.g. location information)
to the existing set of elements and attributes defined by the language. Those tags (including
XML comment tags) not included in the list of recognized elements/attributes will be 
ignored by the compiler, however this decision should have minimal impact on ambigious
errors when compiling programs due to the restriction that all parts require their necessary
attributes, and that all connections require the source to exist. This creates a natural
flow to interpreting the language, such that any errors should be raised by the compiler
during compilation. 

Below is the list of standard elements supported by the language, and their attributes:
\begin{longtable}[c]{ |c|c|c|c| } 
    \hline
    element & input(s) & outputs & attributes [optional]  \\ 
    \hline\hline
    INPUT & none & provides 'name' & scope, size, name, type, [address] \\ 
    OUTPUT & provides 'name' & none & scope, size, name, type, [address] \\ 
    CONSTANT & none & provides 'name' & size, name, type, value \\ 
    SIGNAL & provides 'name' & provides 'name' & scope, size, name, type \\ 
    \hline
    PROGRAM & device inputs & device, global outputs & name \\ 
    BLOCK & as defined & as defined & name, [reference] \\ 
    CONNECTION & none & none & to, from \\
    \hline
    CAST & input & output & name, type \\
    MEM & current & stored & name, initial\_condition \\
    DT & none & dt & name \\
    NOT & input & output & name \\
    AND & input\# (\# $>$ 1) & output & name \\
    OR & input\# (\# $>$ 1) & output & name \\
    NOR & input\# (\# $>$ 1) & output & name \\
    NAND & input\# (\# $>$ 1) & output & name \\
    XOR & input\# (\# $>$ 1) & output & name \\
    BITWISE & input\# (\# $>$ 0) & output & name, operation, [mask] \\
    IF & control, true, false & output & name \\
    COMPARE & lhs, rhs  & output & name, operation \\
    SUM & input\# (\# $>$ 1) & output & name \\
    PROD & input\# (\# $>$ 1) & output & name \\
    GAIN & input & output & name, value \\
    INV & input & output & name \\
    \hline
    MUX & input\# (\# $>$ 1) & provides 'array' & name, type, [address] \\
    DEMUX & array & output\# (\# $>$ 1) & name, type, [address] \\
    STRUCT & none & provides 'struct' & name, member\# (\# $>$ 0) \\
    CONSTRUCT & by definition & provides 'name' & name, definition \\
    DESTRUCT & struct & by definition & name, definition \\
    \hline
    MAP & input (array) & output (array) & name, func (SISO block ref) \\
    FILTER & input (array) & output & name, size, func (SIBO block ref) \\
    REDUCE & input (array) & output & name, initial\_value, func (MISO block ref) \\
    \hline
\end{longtable}

The first group of elements (INPUT, OUTPUT, CONSTANT, NAME) provide named
memory locations for use in the application. All of these elements have a
type attribute where the datatype of the name is specified. INPUT, OUTPUT,
and SIGNAL have a scope attribute, which defines whether the name is local
scope (block-wide), global scope (program wide), or device scope (only
Inputs and Outputs can be device scope). When device scope is chosen, an
IO address must be chosen to specify where to read or write the I/O data
to the interface with the target hardware. The CONSTANT element describes
a named constant, which is initialized to the value provided and will reside
in memory and read each pass during program execution. All of these
elements have a size attribute, which means they can refer to array quantities
as well. A structure can be used as a datatype.

The second group of elements (PROGRAM, BLOCK, CONNECTION) describes block
constructs. This is the basis of how the program works. The PROGRAM element
is a container for the entirety of the program. The PROGRAM element has a
name attribute which describes what the compiled program should be
called by the compiler. The BLOCK element is also a container, but used
throughout the program to encapsulate functionality or define helper parts
in referenced files. BLOCK has an optional reference property which describes
the location of a block in a file using the "/path/to/file.vs$\vert$path$\vert$to$\vert$block"
syntax, where the vertical bars describe the heirarchy required to discover
the referenced block. Any referenced block will have to have connections to 
all of the defined inputs in the referenced block. The outputs are not
required.

The CONNECTION element is how blocks and parts are connected
together. The "to" attribute describes where the connection is headed, and
cannot have a different CONNECTION element with a matching "to" attribute
name. The "from" attribute describes where the connection came from, and
does not have the same restriction. Connections can either be made to named
signals such as INPUTS, OUTPUTS, CONSTANTS, or SIGNAL, or they can be made
implicitly to blocks themselves using "block$\vert$input" or "block$\vert$output" syntax.

The third group is the atomic parts. The Language Reference Manual will go
into more detail here but all of these parts should form the bare minimum 
required by the base language to compose all other required functions from.
All of the atomic parts operate on specific types and have a specific defined
function present in the compiler. All of the blocks have one or more inputs
(except DT) and have exactly 1 output. All of the blocks are time invariant,
,e.g. given the same input they produce the same output, except the DT
and MEM blocks. The MEM block will store the value of something until the next
pass. The DT block outputs the delta time between each pass. Since all blocks
are simple and operate on a defined amount of inputs and outputs, they can be
used with arrays to define parallel operations, e.g. applying the OR gate
operation against two boolean arrays of the same size to produce a third boolean
array of that same size. Structures will not work as inputs to these parts.

All the logic gates besides the NOT gate (AND, OR, etc.) as well as the BITWISE,
SUMMER, and PROD elements are defined as having two or more inputs (BITWISE can
be one if a mask is set). The way this works in practice is that each successive
input increments the number after the word "input" e.g. "input1", "input2",
"input3", etc. when making connections to these parts.

The fourth group describes array and structure utilities. MUX creates arrays from
a group of inputs with the same type, and similarly DEMUX will deconstruct an
array into a group of outputs of the same type. Similar to the atomic gate parts,
these parts allow on the relevant inputs/outputs a variable amount of elements
to be specified using the input\# syntax on the connection elements. The size of
arrays will be static during compilation, and array size will be a quantity traced
between blocks to verify size matching between usages.

CONSTRUCT and DESCTRUCT create and decompose STRUCT elements respectively. The
way this works is that a STRUCT element is defined seperately, with member
attributes defining the name and type of each member of the struct. The CONSTRUCT
element will allow a set of inputs matching the type of each of the members of a
struct to create a new named quantity of that structure, and similarly DESTRUCT
deconstructs a structure into signals that match each of those members. The STRUCT
element can be defined or referenced through a file, allowing a seperate definition
file to be reused over a project. Additionally, a STRUCT can be created from or written
to an array of certain types, using the exact amount of memory required with buffer
space as necessary to represent it as a chunk of memory. This will allow message
definitions to be encoded or decoded to/from a hardware buffer. Lastly, an array
can be composed of struct elements, as long as all elements match that structure
definition.

The last group of elements is the array functions. These functions operate on
arrays per element of the array, and require a referenced function of a certain
number and type of inputs/outputs to translate the input array into the output.
MAP will apply the referenced function of a single input to a single output
(that may or may not matches the input's type). What is important is that the input
array's type and the type of the input to the function match, as well as the
same criteria for the output.

FILTER is similar to MAP in that it has a referenced function, however the output is
required to be a boolean conditional. What FILTER will do is use that conditional
output to filter the input array into an output array. Since there is a design
decision not to allow variable array sizes, FILTER requires a size attribute for
the output, and will not update the output if the size does not match what the
attribute requires. This can be useful for parsing a buffer of word-based definitions,
as we can filter the array of words to find a single UID that is a part of the word
definition and pass that as the output to a parsing function.

The REDUCE element is similar to MAP and FILTER in that it takes an array
argument and use the function reference, however this function will take each
element of the array and apply it to a function that takes two inputs: the first
being the same type as each array element, and the second matching the output type
of the function. REDUCE will start with the first element and the initial value
for the output and recursively run through each element of the array, feeding back
the output as the inital value input for the next iteration. When REDUCE has
exhausted all of the elements of the array, the final output of the function
is returned back as the output of the REDUCE element.

Most attributes for elements are defined with a string. In some cases, it may be 
preferable to use a literal definition for a value instead of creating a reference
or using a named quantity. Every datatype in VisLang has a way of creating a literal.
Examples of literals for all VisLang types are below:
\begin{longtable}[c]{ |c|c| } 
    \hline
    datatype & example literal(s) \\ 
    \hline\hline
    boolean & false, true \\
    single, double & 1.000, 1e-6, 100 \\
    integer & 100, 0x20, 2x1011, 8x671, -120 \\ 
    \hline
    address & 0x1A56, 0x10A8$\vert$14 \\
    arrays & $[1, 2, 3, 4]$ \\
    structures & \{1, \{2, 3\}\} \\
    \hline
\end{longtable}

Booleans can only be false or true. Floating point quantities (single, double) can
be a decimal quantity (with or without significant digits after the decimal point),
or specified using scientific notation e.g. 10e6. Floating point literals can be
specified with a negative sign as well e.g. -1.234e-6. Integer quantities (e.g.
uint8, uint16, uint32, uint64, int8, int16, int32, int64) can be specified as a
decimal quantity (cannot have a decimal point), or using hex (e.g. 0x1A), binary
(e.g.2x1010), or octal (e.g. 8x2462) representation. Only signed integers can have
a negative sign in front. Additionally, for address literals, specifying a bit of
and address can be done with the $\vert$ operator against a hex representation of
the address (e.g. 0x1235$\vert$7). Address literals can only be in hex. Array
literals are created with the bracket operators (e.g. $[true, true, false]$), and
structure literals can be created using the braces operator (e.g. \{0x10, \{1, false\}\}.

Any attribute that accepts a literal can also take a reference to a named value,
in a similar way that block references are defined (e.g. "/path/to/file.vs$\vert$path$\vert$to$\vert$value").

\section{Example Program}

The following program illustrates some of the major features of the language. The
program itself takes a Digital Input on the target device, reads it, and starts a
timer when the input is enabled. When the timer counts up to the target time, it
will set a Digital Output true and reset the timer, creating a fast-blinking light
with a period of 2 seconds.

\includecode{../example/timed-blinking-light/timed-blinking-light.vs}

As noted, the above file contained a reference to another part called timer defined
in timer.vs in the same directory. Any references must take place on a relative path
to that file, and that reference must contain the same number of inputs specified by
the target file inside the file referencing that part. The number of outputs need
not match, but any outputs specified in the file referencing that part must also
match what is available from the target file or an exception will be thrown. All
other unused outputs will be disregarded. The following file displays the target
file, complete with the relevant inputs and outputs as specified/required by the
previous file.

\includecode{../example/timed-blinking-light/timer.vs}

\end{document}

